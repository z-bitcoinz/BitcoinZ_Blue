name: Build and Sign BitcoinZ Blue

on:
  push:
    tags:
      - 'v*'
    branches:
      - master
      - main
  workflow_dispatch:
  workflow_call:  # Allow this workflow to be called by other workflows

jobs:
  build-macos:
    runs-on: macos-latest
    env:
      RUSTFLAGS: "-A warnings"
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          # cache: 'yarn'  # Disabled to ensure fresh build with parameter fixes
          
      - name: Setup Rust 1.81
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: 1.81
          override: true

      - name: Verify Rust version
        run: |
          which rustc
          which cargo
          rustc --version
          cargo --version
          echo "‚úÖ Rust 1.81 confirmed"

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '17'
          # cache: 'yarn'  # Disabled to ensure fresh build with parameter fixes

      - name: Clean build artifacts
        run: |
          rm -rf node_modules
          rm -rf native/target
          rm -rf dist

      - name: Setup Python for DMG creation
        run: |
          # Install Python 3 if not available
          if ! command -v python3 &> /dev/null; then
            echo "Installing Python 3..."
            brew install python@3
          fi
          
          # Create symlink for electron-builder DMG creation
          echo "Python 3 location: $(which python3)"
          # Use /usr/local/bin/python instead of /usr/bin/python as it's writable
          if [ ! -f /usr/local/bin/python ]; then
            ln -s $(which python3) /usr/local/bin/python
          fi
          
          # Verify Python is available
          /usr/local/bin/python --version
          
      - name: Install dependencies
        run: yarn install

      - name: Build native module
        run: |
          # Verify we're using the right Rust version
          echo "Using Rust version:"
          rustc --version

          cd native

          # Handle Cargo.lock version issues
          if [ -f "Cargo.lock" ]; then
            echo "üîß Removing existing Cargo.lock to avoid version conflicts"
            rm Cargo.lock
          fi

          # Generate new lock file and build (allow warnings)
          cargo generate-lockfile
          cargo build --release
          cp target/release/libbitcoinz_wallet_lite.dylib ../src/native.node
          
      - name: Build macOS app with ad-hoc signing
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: false
          # Force electron-builder to use ad-hoc signing
          CSC_LINK: ""
          CSC_KEY_PASSWORD: ""
          CODESIGN_IDENTITY: "-"  # This tells electron-builder to use ad-hoc signing
          # Skip rebuilding native deps since we already built them
          ELECTRON_BUILDER_SKIP_REBUILD: true
        timeout-minutes: 30  # Add timeout to prevent hanging
        run: |
          echo "Starting macOS build with ad-hoc signing..."
          yarn --version
          node --version
          
          # First build without packaging
          yarn build
          
          # Copy native module to the right place for electron-builder
          cp src/native.node build/
          
          # Copy electron.js to build directory
          cp public/electron.js build/
          
          # Now use electron-builder with ad-hoc signing, skip rebuild
          echo "üîê Building and signing macOS app..."
          # Build apps without DMG (to avoid Python issue)
          npx electron-builder -m \
            --config.extraMetadata.main=build/electron.js \
            --config.mac.identity=null \
            --config.mac.type=distribution \
            --config.mac.target=dir \
            --config.npmRebuild=false \
            --config.buildDependenciesFromSource=false \
            --publish never
          
          # Verify the apps are signed BEFORE zipping
          echo "üìã Verifying signatures..."
          find dist -name "*.app" -type d | while read -r app; do
            echo "Checking: $app"
            if codesign -dv "$app" 2>&1 | grep -q "adhoc"; then
              echo "‚úÖ Ad-hoc signature found: $app"
            else
              echo "‚ö†Ô∏è  No ad-hoc signature found, applying now..."
              codesign --force --deep --sign - "$app"
              echo "‚úÖ Ad-hoc signature applied: $app"
            fi
            
            # Remove extended attributes
            xattr -cr "$app"
          done
          
          echo "‚úÖ macOS build and signing complete"
          
      - name: Create DMG files using custom script
        run: |
          echo "üì¶ Creating DMG files..."
          # Make the script executable
          chmod +x scripts/create-dmg.sh
          
          # Run the custom DMG creation script
          ./scripts/create-dmg.sh
          
          echo "‚úÖ DMG creation complete"
          
          # List created DMG files
          ls -la dist/*.dmg || true


      - name: Upload macOS ARM64 (Apple Silicon)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: BitcoinZ-Blue-macOS-AppleSilicon
          path: |
            dist/*arm64.dmg

      - name: Upload macOS Intel
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: BitcoinZ-Blue-macOS-Intel
          path: |
            dist/*x64.dmg


  build-windows:
    runs-on: windows-latest
    env:
      RUSTFLAGS: "-A warnings"
    steps:
      - uses: actions/checkout@v3

      - name: Setup Rust 1.81
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: 1.81
          override: true

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          # cache: 'yarn'  # Disabled to ensure fresh build with parameter fixes

      - name: Clean build artifacts
        run: |
          if (Test-Path "node_modules") { Remove-Item -Recurse -Force "node_modules" }
          if (Test-Path "native/target") { Remove-Item -Recurse -Force "native/target" }
          if (Test-Path "dist") { Remove-Item -Recurse -Force "dist" }
        shell: powershell

      - name: Build native module for Windows
        run: |
          echo "Building native Rust module for Windows..."
          cd native
          
          # Remove old lock file if exists
          if (Test-Path "Cargo.lock") { 
            Remove-Item "Cargo.lock" 
          }
          
          # Build the native module
          cargo build --release
          
          # Check what was built
          echo "Built files:"
          Get-ChildItem target/release/*.dll
          
          # Copy the DLL to src/native.node
          $dll = Get-ChildItem target/release/*.dll | Where-Object { $_.Name -match "bitcoinz|zecwallet" } | Select-Object -First 1
          if ($dll) {
            Copy-Item $dll.FullName ../src/native.node
            echo "[SUCCESS] Copied $($dll.Name) to src/native.node"
          } else {
            throw "Could not find native module DLL"
          }
        shell: powershell

      - name: Build Windows app
        run: |
          echo "Starting Windows build..."
          npm --version
          node --version
          
          # Remove yarn.lock to use npm
          if (Test-Path "yarn.lock") {
            Remove-Item "yarn.lock"
            echo "Removed yarn.lock to use npm instead"
          }
          
          # Configure npm for better reliability
          npm config set registry https://registry.npmjs.org/
          npm config set fetch-retries 5
          npm config set fetch-retry-mintimeout 20000
          npm config set fetch-retry-maxtimeout 120000
          npm config set loglevel verbose
          
          # Clean npm cache
          npm cache clean --force
          
          # Install dependencies using npm (more stable on Windows)
          echo "Installing dependencies with npm..."
          npm install --no-audit --no-fund
          
          # Install cross-env globally if missing
          npm install -g cross-env
          
          # Build the app (skip native build as we already did it)
          $env:SKIP_NATIVE_BUILD = "true"
          npm run build
          
          # Create build directory if it doesn't exist
          if (!(Test-Path "build")) {
            New-Item -ItemType Directory -Path "build"
          }
          
          # Copy native module to build directory
          Copy-Item src/native.node build/
          
          # Copy electron.js to build directory
          Copy-Item public/electron.js build/
          
          # Build with electron-builder
          npx electron-builder -w --config.extraMetadata.main=build/electron.js --publish never
        shell: powershell

      - name: Sign Windows executables (enhanced self-signed)
        run: |
          echo "[LOCK] Starting Windows code signing..."
          
          # Create self-signed certificate
          $certParams = @{
            Subject = "CN=BitcoinZ Community, O=BitcoinZ Blue, C=US"
            Type = "CodeSigning"
            KeySpec = "Signature"
            KeyUsage = "DigitalSignature"
            FriendlyName = "BitcoinZ Blue Code Signing"
            CertStoreLocation = "Cert:\\CurrentUser\\My"
            KeyExportPolicy = "Exportable"
            KeyLength = 2048
            KeyAlgorithm = "RSA"
            HashAlgorithm = "SHA256"
          }
          
          $cert = New-SelfSignedCertificate @certParams
          $certPath = "Cert:\\CurrentUser\\My\\$($cert.Thumbprint)"
          
          # Export certificate
          Export-Certificate -Cert $certPath -FilePath "dist\\BitcoinZ-Blue-Certificate.cer" -Type CERT
          
          # Sign all executables
          $exeFiles = Get-ChildItem -Path dist -Filter *.exe
          foreach ($exe in $exeFiles) {
            Write-Host "Signing: $($exe.Name)"
            $signParams = @{
              FilePath = $exe.FullName
              Certificate = (Get-Item $certPath)
              TimestampServer = "http://timestamp.digicert.com"
              HashAlgorithm = "SHA256"
            }
            Set-AuthenticodeSignature @signParams
            
            $sig = Get-AuthenticodeSignature $exe.FullName
            Write-Host "Status: $($sig.Status)"
          }
          
          Write-Host "[SUCCESS] Windows signing complete"
        shell: powershell

      - name: Upload Windows Installer (EXE)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: BitcoinZ-Blue-Windows-Installer
          path: |
            dist/*.exe

      - name: Upload Windows Portable (ZIP)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: BitcoinZ-Blue-Windows-Portable
          path: |
            dist/*.zip

      - name: Create Windows security report
        run: |
          echo "# Windows Security Report" > windows-security.md
          echo "" >> windows-security.md
          echo "## Code Signing Status" >> windows-security.md
          echo "- [OK] Executable is digitally signed" >> windows-security.md
          echo "- [OK] Self-signed certificate for integrity verification" >> windows-security.md
          echo "- [OK] Timestamp server used for long-term validity" >> windows-security.md
          echo "" >> windows-security.md
          echo "## Windows Defender SmartScreen" >> windows-security.md
          echo "- First-time downloads may show SmartScreen warning" >> windows-security.md
          echo "- Click 'More info' then 'Run anyway' to proceed" >> windows-security.md
          echo "- This is normal for new software publishers" >> windows-security.md
        shell: bash



  build-linux:
    runs-on: ubuntu-latest
    env:
      RUSTFLAGS: "-A warnings"
    steps:
      - uses: actions/checkout@v3

      - name: Setup Rust 1.81
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: 1.81
          override: true

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          # cache: 'yarn'  # Disabled to ensure fresh build with parameter fixes
          
      - name: Clean build artifacts
        run: |
          rm -rf node_modules
          rm -rf native/target
          rm -rf dist

      - name: Build Linux app
        run: |
          echo "Starting Linux build..."
          yarn --version
          node --version
          yarn install
          yarn dist:linux

      - name: Upload Linux AppImage (Universal)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: BitcoinZ-Blue-Linux-AppImage
          path: |
            dist/*.AppImage

      - name: Upload Linux DEB Package
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: BitcoinZ-Blue-Linux-DEB
          path: |
            dist/*.deb

  # Sigstore signing job that runs after all builds
  sigstore-sign:
    needs: [build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        
      - name: Sign artifacts with Sigstore
        run: |
          echo "üîí Starting Sigstore signing process..."
          
          # Create dist directory
          mkdir -p dist
          
          # Copy all artifacts to dist
          find artifacts -type f \( -name "*.zip" -o -name "*.exe" -o -name "*.AppImage" -o -name "*.deb" \) -exec cp {} dist/ \;
          
          # Sign each artifact
          cd dist
          for file in *; do
            if [ -f "$file" ]; then
              echo "üîê Signing: $file"
              
              # Sign with Sigstore (keyless signing)
              cosign sign-blob \
                --output-signature="${file}.sig" \
                --output-certificate="${file}.pem" \
                "$file" --yes
                
              echo "‚úÖ Signed: $file"
              echo "   Signature: ${file}.sig"
              echo "   Certificate: ${file}.pem"
            fi
          done
          
          # Create verification script
          cat > verify-signatures.sh << 'EOF'
          #!/bin/bash
          
          # BitcoinZ Blue Signature Verification Script
          echo "üîç Verifying BitcoinZ Blue signatures..."
          
          # Install cosign if not present
          if ! command -v cosign &> /dev/null; then
              echo "Please install cosign from: https://github.com/sigstore/cosign#installation"
              exit 1
          fi
          
          # Verify each file
          for file in *.{exe,zip,AppImage,deb}; do
              if [ -f "$file" ] && [ -f "${file}.sig" ] && [ -f "${file}.pem" ]; then
                  echo "üîê Verifying: $file"
                  
                  if cosign verify-blob \
                      --certificate="${file}.pem" \
                      --signature="${file}.sig" \
                      --certificate-identity-regexp=".*" \
                      --certificate-oidc-issuer-regexp=".*" \
                      "$file"; then
                      echo "‚úÖ Valid signature: $file"
                  else
                      echo "‚ùå Invalid signature: $file"
                  fi
              fi
          done
          
          echo "üéâ Verification complete!"
          EOF
          
          chmod +x verify-signatures.sh
          
          echo "üéâ Sigstore signing complete!"
          echo ""
          echo "üìã Signed files:"
          ls -la *.sig *.pem 2>/dev/null || true
          
      - name: Upload signed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: BitcoinZ-Blue-Signed-Artifacts
          path: |
            dist/*
            
      - name: Create signing report
        run: |
          cat > signing-report.md << 'EOF'
          # BitcoinZ Blue Code Signing Report
          
          ## üîê Signing Methods Used
          
          ### macOS
          - **Ad-hoc signing**: Prevents "damaged app" errors
          - **Sigstore signatures**: Cryptographic verification
          
          ### Windows  
          - **Self-signed certificate**: Basic integrity verification
          - **Sigstore signatures**: Additional trust layer
          
          ### Linux
          - **Sigstore signatures**: Primary verification method
          
          ## ‚úÖ How to Verify Downloads
          
          1. Download the app and signature files (.sig, .pem)
          2. Run the verification script: `./verify-signatures.sh`
          3. Or manually verify with cosign:
             ```bash
             cosign verify-blob \
               --certificate="app.pem" \
               --signature="app.sig" \
               --certificate-identity-regexp=".*" \
               --certificate-oidc-issuer-regexp=".*" \
               "app"
             ```
          
          ## üõ°Ô∏è Security Benefits
          
          - **Transparency**: All signatures are publicly verifiable
          - **Integrity**: Ensures files haven't been tampered with
          - **Free**: No certificate costs or annual fees
          - **Open Source**: Using Sigstore's transparent infrastructure
          
          ## üìñ Learn More
          
          - [Sigstore Documentation](https://docs.sigstore.dev/)
          - [BitcoinZ Blue Security](https://github.com/z-bitcoinz/BitcoinZ_Blue)
          EOF
          
          echo "üìÑ Signing report created"
